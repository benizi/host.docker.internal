#!/bin/sh

# exit on errors
set -e

# set xtrace if either `$DEBUG` or `$DEBUG_SCRIPT` is set
test -z "$DEBUG$DEBUG_SCRIPT" || set -x

# print an error message and exit with rc=1
die() {
  printf '%s\n' "$*" >&2
  exit 1
}

# true if the current process has $1 in its effective capability set
has_cap() {
  awk '/^CapEff:/ { print $NF }' /proc/self/status |
  xargs -iCAPS capsh --decode=CAPS |
  awk -v RS='[,=+[:space:]]' 'NR>1' |
  grep -q $1
}

# return true if all capabilities are present, printing errors otherwise
ensure_caps() {
  local all=true
  for cap
  do
    if ! has_cap $cap
    then
      all=false
      echo "Missing capability: $cap" >&2
    fi
  done
  $all || die "Don't have all capabilities: [$*]"
}

# if `$HOST` is set, look up its IP for use as the destination
lookup_ip() {
  if test -n "$HOST"
  then
    getent ahostsv4 "$HOST" |
    awk '!seen[$1]++ { print $1 }' |
    grep . || die "Couldn't find (IPv4) address for HOST=[$HOST]"
  fi
}

# print the IPv4 address of the default gateway
default_gateway() {
  ip -4 route show default |
  awk '{ print $3 }' |
  grep . || die "Couldn't determine default gateway"
}

# print the current host's IP
myip() {
  ip -4 addr |
  tac |
  awk '$1 == "inet" { print $2 }'
}

# set `$IP` to the first of the following that is present:
# - `$IP` (can be passed in)
# - IP address of `$HOST`
# - IP address of default gateway
# set default `$PORTS`
set_destination() {
  : ${IP:=$(lookup_ip)}
  : ${IP:=$(default_gateway)}
  : ${PORTS:=0:65535}
  test -n "$IP" || die "Couldn't determine IP for forwarding"
  export IP PORTS
}

# set up forwarding rules for TCP and UDP traffic on the specified ports
start_forwarding() {
  echo $(hostname) $(myip)
  for port in $(echo $PORTS)
  do
    echo FORWARDING IP=$IP PORTS=$port
    for proto in tcp udp
    do
      iptables \
        --table nat \
        --insert PREROUTING \
        --protocol $proto \
        --dport $port \
        --jump DNAT \
        --to-destination $IP
    done
  done
}

# print environment if either `$DEBUG` or `$DEBUG_ENV` is set
debug_env() {
  test -z "$DEBUG$DEBUG_ENV" || env | sort >&2
}

# loop, printing statistics, exiting when container is stopped by signal
loop_stats() {
  : ${STATS:=1h}

  trap : TERM INT
  (
    while :
    do
      case "$STATS" in
        (0) sleep 1h ;;
        (*)
          iptables -t nat -L PREROUTING -v |
          sed "s/^/$(date +"%F %T") /" >&2
          sleep $STATS
          ;;
      esac
    done
  ) &
  wait
}

main() {
  ensure_caps cap_net_admin cap_net_raw
  set_destination
  start_forwarding
  debug_env
  loop_stats
}

test $# -gt 0 || set -- main
eval "$*"
